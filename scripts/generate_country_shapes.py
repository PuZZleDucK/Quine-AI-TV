#!/usr/bin/env python3
"""Generate normalized country coast outlines for Tiny Travel Desk maps.

Outputs `src/data/countryShapes.js` with points in normalized coordinates.
"""

from __future__ import annotations

import json
import math
import pathlib
import urllib.request
from typing import Iterable

SOURCE_URL = "https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_50m_admin_0_countries.geojson"
OUT_PATH = pathlib.Path("src/data/countryShapes.js")

TARGETS = {
    "Portugal": "Portugal",
    "Japan": "Japan",
    "Morocco": "Morocco",
    "Iceland": "Iceland",
    "Mexico": "Mexico",
    "Vietnam": "Vietnam",
    "TÃ¼rkiye": "Turkey",
    "Scotland": "United Kingdom",
    "USA": "United States of America",
    "Denmark": "Denmark",
}


def ring_area(points: list[list[float]]) -> float:
    area = 0.0
    for i in range(len(points)):
        x1, y1 = points[i]
        x2, y2 = points[(i + 1) % len(points)]
        area += (x1 * y2) - (x2 * y1)
    return abs(area) * 0.5


def rdp(points: list[list[float]], epsilon: float) -> list[list[float]]:
    if len(points) < 3:
        return points[:]

    start = points[0]
    end = points[-1]
    sx, sy = start
    ex, ey = end
    dx = ex - sx
    dy = ey - sy
    den = math.hypot(dx, dy)

    max_d = -1.0
    idx = -1
    for i in range(1, len(points) - 1):
        px, py = points[i]
        if den == 0:
            d = math.hypot(px - sx, py - sy)
        else:
            d = abs(dy * px - dx * py + ex * sy - ey * sx) / den
        if d > max_d:
            max_d = d
            idx = i

    if max_d > epsilon:
        left = rdp(points[: idx + 1], epsilon)
        right = rdp(points[idx:], epsilon)
        return left[:-1] + right
    return [start, end]


def largest_ring(geom: dict) -> list[list[float]]:
    gtype = geom.get("type")
    coords = geom.get("coordinates", [])
    rings: list[list[list[float]]] = []
    if gtype == "Polygon":
        if coords:
            rings.append(coords[0])
    elif gtype == "MultiPolygon":
        for poly in coords:
            if poly:
                rings.append(poly[0])
    if not rings:
        raise ValueError(f"Unsupported/empty geometry type: {gtype}")
    return max(rings, key=ring_area)


def normalize(points: Iterable[list[float]]) -> list[list[float]]:
    pts = list(points)
    xs = [p[0] for p in pts]
    ys = [p[1] for p in pts]
    minx, maxx = min(xs), max(xs)
    miny, maxy = min(ys), max(ys)
    cx = (minx + maxx) * 0.5
    cy = (miny + maxy) * 0.5
    scale = max(maxx - minx, maxy - miny) * 0.5
    if scale <= 1e-9:
        scale = 1.0

    out = []
    for x, y in pts:
        nx = (x - cx) / scale
        ny = -((y - cy) / scale)
        out.append([round(nx, 5), round(ny, 5)])
    return out


def load_geojson() -> dict:
    with urllib.request.urlopen(SOURCE_URL, timeout=30) as resp:
        data = resp.read().decode("utf-8")
    return json.loads(data)


def find_feature(features: list[dict], admin_name: str) -> dict:
    for f in features:
        if f.get("properties", {}).get("ADMIN") == admin_name:
            return f
    raise KeyError(f"Country not found in source data: {admin_name}")


def main() -> None:
    geo = load_geojson()
    feats = geo.get("features", [])

    result: dict[str, list[list[float]]] = {}
    for app_country, admin_name in TARGETS.items():
        feature = find_feature(feats, admin_name)
        ring = largest_ring(feature.get("geometry", {}))
        # remove duplicated closing point if present
        if ring and ring[0] == ring[-1]:
            ring = ring[:-1]
        simp = rdp(ring, epsilon=0.22)
        # guard minimum complexity
        if len(simp) < 20:
            simp = rdp(ring, epsilon=0.10)
        result[app_country] = normalize(simp)

    OUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    with OUT_PATH.open("w", encoding="utf-8") as f:
        f.write("// Generated by scripts/generate_country_shapes.py\n")
        f.write("export const COUNTRY_SHAPES = ")
        json.dump(result, f, ensure_ascii=False, separators=(",", ":"))
        f.write(";\n")

    print(f"wrote {OUT_PATH} ({len(result)} country outlines)")


if __name__ == "__main__":
    main()
